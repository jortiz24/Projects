##leetcode question 420, code works for majority of cases, however leetcode has some incorrect test cases so its difficult to tell where certain improvements can be made. 
##The code is more accurate compared to leetcode in the case where passwords longer than 20 characters can consolidate hte strings of 3 or more repeating characters for every 3 characters over 20 in my solutions

class Solution:
    def strongPasswordChecker(self, password: str) -> int:

        if len(password) < 4:
            return 6-len(password)
        

            
        out = 0
        breaks = 0
        excess = 0
        
        if len(password) > 20:
            print(len(password))
            excess += len(password) - 20

        
        
        
        position = 0
        counter = 1
        check = password[position]

        while position < len(password) - 2:

            if check == password[position+counter]:
                
                if position + counter >= len(password) - 1:
                    counter += 1
                    breaks += (counter)//3
                    break
                else:
                    counter += 1
                
            else:
                breaks += (counter)//3
                position += counter
                check = password[position]
                counter = 1
        
        

        
        
        if any(num in "0123456789" for num in password) == False:
                
            out += 1
        if password.isupper() == True:
            out += 1
        elif password.islower() == True:
            out += 1
        elif any(letter in "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" for letter in password) == False:
              out += 2
        elif len(password) + out < 6:
             out+= 6 - len(password) + out 

        if breaks - excess//3 >= out + excess:
            return breaks - excess//3
        else:
            return out + excess 
        
